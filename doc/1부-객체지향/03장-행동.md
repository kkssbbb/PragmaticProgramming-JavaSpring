## 03장: 행동

객체 지향 프로그래밍에서 객체는 단순한 데이터 덩어리가 아니라 능동적으로 **행동**하는 주체로 존재해야 한다. 객체를 구분짓는 것은 데이터가 아닌 행동이며, 행동 중심의 사고는 자연스럽게 객체 지향적인 코드를 작성하도록 이끌어준다.

### 행동하는 객체란?

객체가 행동한다는 것은 어떤 의미일까? 그리고 어떻게 객체를 행동하게 만들 수 있을까?

*   **TDA(Tell, Don't Ask) 원칙 적용**: 객체가 필요한 데이터를 직접 요청하여 처리하는 것이 아니라, 객체에게 무엇을 해야 하는지 알려주고(Tell) 객체 스스로 행동하게 만드는 원칙이다. 이미 속성을 가진 객체가 있을 때, 이 원칙을 적용하여 수동적인 객체를 능동적인 객체로 변화시킬 수 있다.

### 초기 설계 단계에서의 행동 중심 접근

아직 객체의 속성이 정의되지 않은 초기 설계 단계에서는 어떻게 행동에 집중하는 객체를 만들 수 있을까?

예를 들어 `자동차` 클래스를 설계한다고 가정해 보자. 자동차에 필요한 속성(멤버 변수)을 먼저 나열하는 대신, 자동차가 어떤 **행동**(메서드)을 해야 하는지 먼저 고민하는 것이다. `달린다()`, `멈춘다()`, `방향을 바꾼다()`와 같은 행동을 먼저 정의하면, 이 클래스의 객체가 어떤 역할을 수행하고 어디에 어떻게 사용될지 명확해진다.

행동에 집중한 코드가 데이터에 집중한 코드보다 항상 더 좋다고 단정 지을 수는 없다. 하지만 객체 지향의 관점에서 볼 때, 행동을 위주로 설계한 클래스가 더 객체 지향적이라고 할 수 있다. 왜냐하면 객체 지향 시스템에서 객체들은 서로 협력해야 하며, 협력을 위해서는 상대방 객체에게 행동을 요구할 수 있어야 하기 때문이다.

> 데이터가 객체를 결정하지 않는다. 행동이 객체를 결정한다.

예를 들어 클래스의 이름을 짓는 상황을 생각해 보자.

*   **데이터 중심 사고**: 속성만 보고는 클래스의 이름을 명확히 정의하기 어려울 수 있다. (예: 코드 3.3, 78p - 책 내용 참조)
*   **행동 중심 사고**: 객체가 수행하는 행동을 보면 그 객체의 역할을 파악하기 쉽고, 클래스 이름도 자연스럽게 도출된다. (예: 코드 3.4 - 책 내용 참조)

행동을 먼저 고민하면 클래스의 역할이 명확해진다. 어떤 행동을 할 수 있는지가 곧 역할을 만들고, 이러한 역할이 모여 객체를 정의하는 것이다.

### 3.1 덕 타이핑 (Duck Typing)

객체 지향 패러다임은 행동을 강조한다. 이러한 사실을 뒷받침하는 용어 중 하나가 **덕 타이핑(duck typing)**이다.

> "만약 어떤 새가 오리처럼 걷고, 오리처럼 꽥꽥거린다면, 나는 그 새를 오리라고 부를 것이다." - 덕 테스트에서 유래

개발자 관점에서 이 말은 "행동이 같다면 같은 타입(클래스)으로 간주하겠다"는 의미로 해석될 수 있다.

자바는 정적 타이핑 언어라 덕 타이핑을 직접적으로 지원하지 않지만, 동적 타이핑을 지원하는 타입스크립트 같은 언어에서는 상속 관계를 맺지 않아도 객체의 행동(메서드 시그니처)이 같다면 같은 타입으로 취급할 수 있다. 이는 타입스크립트가 행동이 같은 두 클래스를 동일하게 보는 덕 타이핑 개념을 지원하기 때문이다.

결국, 행동이 곧 역할을 정의하고, 역할이 곧 객체를 정의한다는 점을 다시 한번 강조한다.

### 3.2 행동과 구현의 분리

행동을 고민하는 단계에서부터 구현이나 알고리즘을 함께 고민해서는 안 된다.

*   행동을 고민하면서 동시에 구현을 생각하면 다시 데이터 위주의 사고로 돌아갈 가능성이 높다.
*   "어떻게 구현할 것인가"는 나중 문제이며, 행동을 고민하는 순간에는 순수하게 "이 클래스가 어떤 동작을 수행할 수 있어야 하는가"에 집중해야 한다.

그렇다면 어떻게 구현에 얽매이지 않고 행동에만 집중할 수 있을까? 바로 자바의 **인터페이스(Interface)**를 활용하는 것이다.

시스템 개발 초기 단계에서 팀원들과 함께 역할과 행동을 기반으로 인터페이스를 정의한다. 모든 합의가 끝나면 각 개발자는 자신이 맡은 객체의 구체적인 구현에 집중할 수 있다.

만약 협력 객체를 개발하는 팀원이 정의된 인터페이스를 제대로 지키지 않으면 어떻게 될까? 이미 인터페이스를 기반으로 협력 방식을 약속했기 때문에, "그래서는 안 된다"가 답이다. 이런 경우 이해관계자들이 모여 설계를 다시 논의해야 한다.

> 인터페이스는 곧 계약이다.

이 말이 있는 이유는 인터페이스가 반드시 지켜져야 하기 때문이다. 계약이 깨지면 시스템 전체가 무너질 수 있다. 따라서 계약이 제대로 지켜지고 있는지, 항상 유지되고 있는지 감시할 필요가 있으며, 이때 **테스트 코드**가 중요한 역할을 한다.

### 3.3 인터페이스 (Interface)

> 여기서 (인터페이스의)한 가지 오해를 바로잡고 넘어가자.

*   **행동이 곧 인터페이스는 아니다.** 행동과 인터페이스는 구분할 필요가 있다.
*   자바의 인터페이스는 어떤 행동을 지시하기 위해 사용할 수 있는 **행동들의 집합**이다.

인터페이스는 일종의 계약서다
- **Interface**: 인터페이스란 "나(객체 또는 시스템)를 조작하고 싶다면, 이러한 메시지(메서드 호출)를 보내면 된다"라고 외부에 알려주는 수단이다.

*   **API (Application Programming Interface)**: 애플리케이션을 조작하고 싶을 때 어떤 메시지를 보내야 하는지 알려주는 규약이다.
*   **UI (User Interface)**: 사용자가 프로그램을 조작하고 싶을 때 어떤 방식으로 상호작용해야 하는지 알려주는 매개체이다.

마찬가지로 자바의 인터페이스는 특정 객체를 어떻게 사용하면 되는지 외부 객체에게 알려주는 역할을 한다. 다시 말해, 인터페이스는 어떤 행동을 지시하기 위해 사용할 수 있는 행동들의 집합인 것이다.

이러한 맥락에서 자바 인터페이스에 대한 두 가지 사실을 쉽게 이해할 수 있다. (자바 버전에 따라 차이가 있을 수 있다.)

1.  **private 접근 제어자 제한 (Java 8 기준)**: 인터페이스 내 메서드에 `private`을 선언하면 컴파일 에러가 발생했다. (Java 9 이후부터는 private 메서드 사용 가능)
2.  **public 접근 제어자 중복**: 인터페이스 내 메서드에 `public`을 명시하면, IDE 등에서 "public은 인터페이스에서 기본값이므로 명시하지 않아도 된다"는 안내를 볼 수 있다.
    *   이는 인터페이스의 본질적인 목적이 "외부 세계에 자신을 다루는 방법을 공개적으로 알리는 것"이기 때문이다.

#### 인터페이스의 중요성
*   **행동과 역할 중심 사고 유도**: 인터페이스를 정의하는 과정에서 자연스럽게 객체의 행동과 역할을 고민하게 된다.
*   **결합도 감소**: 객체 간의 결합도를 낮춰 시스템의 유연성을 높인다.
    *   결과적으로 코드의 재사용성과 유지보수성이 향상된다.
    *   모듈화에도 기여하여 각 부분을 독립적으로 개발하고 테스트하기 용이해진다.

### 3.4 행동과 역할의 지속적인 고민

역할에 집중하는 사고방식을 익히기 위해서는 꾸준한 훈련이 필요하다.

*   반복적이고 의식적으로 "객체가 어떤 행동을 해야 하는가?"를 고민해야 한다.
*   "어떤 행동들을 모아 구조적으로 타당한 역할을 만들 수 있을까?"를 계속해서 고민해야 한다.

행동과 역할에 집중하라는 것이 단순히 추상화를 많이 하라는 뜻은 아니다. 역할과 추상은 동일한 개념이 아니기 때문이다.

### 3.5 메서드 (Method)

우리는 왜 클래스 내부에 정의된 함수를 "메서드"라고 부를까?

"메서드(method)"는 "방법"이라는 뜻을 가지고 있다. 즉, 어떤 메시지(요청)를 받았을 때 그것을 **어떻게 처리하는지에 대한 방법(method)** 을 기술하는 것이다.

#### 메서드(Method) vs 함수(Function)

함수와 메서드는 다른 개념이며, 함수의 정의만으로는 메서드를 온전히 설명하기 어렵다.

| 구분     | 함수 (Function)                                                                 | 메서드 (Method)                                                                                                |
|----------|---------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------|
| **핵심** | 입력값과 출력값 사이의 정적인 대응 관계.                                                | 객체가 메시지를 처리하는 방법(절차). 객체의 상태에 따라 동일 메시지라도 다른 결과를 반환할 수 있음.                               |
| **특징** | 동일 입력에 대해 항상 동일 출력을 보장 (참조 투명성). 상태를 갖지 않거나 변경하지 않음 (Side effect 최소화). | 객체의 상태(멤버 변수)에 접근하고 수정할 수 있음. 객체 지향의 다형성을 통해 동일 메시지라도 다른 객체에서 다른 방식으로 동작. |
| **예시** | `int sum(int a, int b) { return a + b; }`                                       | `class Counter { int count = 0; void increment() { this.count++; } }`                                       |

객체 지향 프로그래밍에서 함수를 메서드라고 부르는 이유는, 객체는 협력하는 다른 객체에게 "무엇을 해달라"는 메시지만 보낼 뿐, 실제로 그 요청을 어떤 **방법(method)** 으로 처리할지는 메시지를 수신한 객체 자신이 결정하기 때문이다.

#### 메서드 구현에 대한 관점

메서드를 어떻게 구현할지에만 집중하는 것은 바람직하지 않을 수 있다.

*   메서드는 결국 어떤 메시지를 어떻게 처리하는지 서술하는 것이므로, 그 본질은 알고리즘에 가깝다.
*   알고리즘과 구현에만 집착하게 되면, 결국 절차 지향적인 방식으로 코드를 작성하게 될 수 있다.
*   객체 지향 프로그래밍에서 정말 중요한 것은 **책임을 적절히 나누고, 메시지를 통해 객체 간의 협력 관계를 효과적으로 구축**하는 것이다.



회사를 다니면서 개발 지식도 중요하지만, 도메인 지식 또한 그에 못지않게 중요하다는 것을 경험을 통해 알게 된다. 비즈니스 도메인에 대한 깊은 이해와 지식을 바탕으로 자연스러운 객체 모델과 책임 구조를 설계할 수 있기 때문이다.

### 03장 정리: 행동 중심 설계의 가치

03장은 저자가 객체 지향 프로그래밍에서 **행동**의 중요성에 대해 알려준다.

*   객체는 데이터가 아닌 **행동**으로 정의된다.
*   행동을 먼저 고민하면 객체의 **역할**이 명확해지고, 이는 곧 응집도 높고 결합도 낮은 설계를 가능하게 한다.
*   **TDA 원칙**, **덕 타이핑**, **인터페이스**와 같은 개념들은 모두 행동 중심 설계를 뒷받침한다.
*   메서드는 단순히 기능을 구현하는 것을 넘어, 객체가 메시지를 처리하는 **방법**을 정의하는 것이다.
*   진정한 객체 지향 설계는 단순히 코드를 작성하는 것을 넘어, 객체 간의 **책임**을 분배하고 **협력** 관계를 구축하는 데 중점을 둔다.

궁극적으로 행동과 역할에 집중하는 사고방식은 유지보수하기 쉽고, 확장 가능하며, 이해하기 쉬운 코드를 작성하는 데 핵심적인 역할을 한다. 

#### 03장을 읽은 후 나의 생각
> "나는 지금까지 개발에서 단순 구현은 누구나 하는 거고 이미 구현된 레퍼런스가 많기 때문에 개발을 잘한다의 척도가 될 수 없다고 생각했다. 그러면 항상 따라오는 '그러면 개발을 잘한다는 건 뭘 어떻게 해야 잘한다고 할 수 있는 건데?'라는 반문에 항상 애매모호하게 효율적이고 유지보수성이 높은 코드를 잘 짜야 개발을 잘 하는 거라고 생각했었다. 그런데 이 책을 읽고 이제는 '개발을 잘 한다는 건 구현보다는 객체들 간에 책임을 잘 나누고 메시지를 통해 객체들 간에 협력 관계를 잘 구축하는 게 잘하는 거야'라고 좀 더 구체적으로 말할 수 있게 됐다." - 나의생각